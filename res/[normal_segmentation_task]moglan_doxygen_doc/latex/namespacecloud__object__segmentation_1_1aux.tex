\hypertarget{namespacecloud__object__segmentation_1_1aux}{}\section{cloud\+\_\+object\+\_\+segmentation\+:\+:aux Namespace Reference}
\label{namespacecloud__object__segmentation_1_1aux}\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
float \hyperlink{namespacecloud__object__segmentation_1_1aux_a4b661185614d1037447a89a148a204eb}{set\+\_\+precision} (float float\+\_\+num, float precision)
\begin{DoxyCompactList}\small\item\em set\+\_\+precision sets the number of digits after the decimal \end{DoxyCompactList}\item 
float \hyperlink{namespacecloud__object__segmentation_1_1aux_afdc9858a2a1aa966c6b9cf71a4549718}{map} (float x, float in\+\_\+min, float in\+\_\+max, float out\+\_\+min, float out\+\_\+max)
\begin{DoxyCompactList}\small\item\em map maps a number found within a range to another range \end{DoxyCompactList}\item 
float \hyperlink{namespacecloud__object__segmentation_1_1aux_a16d1866d46bb2c56c66f9d703fa7189e}{float\+\_\+avg} (std\+::vector$<$ float $>$ floats)
\begin{DoxyCompactList}\small\item\em float\+\_\+avg calculates the average of float numbers \end{DoxyCompactList}\item 
bool \hyperlink{namespacecloud__object__segmentation_1_1aux_a6dbc39e59b20bcc59affd0aad8496dc3}{float\+\_\+cmp} (float float\+\_\+1, float float\+\_\+2, float precision)
\begin{DoxyCompactList}\small\item\em float\+\_\+cmp compares two floats with a certain precision \end{DoxyCompactList}\item 
std\+::vector$<$ float $>$ \hyperlink{namespacecloud__object__segmentation_1_1aux_ae659a392c3508e64e4a82bb61ee4cc86}{spherical\+\_\+coords} (\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{aux\+::vector3} vect)
\begin{DoxyCompactList}\small\item\em spherical\+\_\+coordinates calculates the spherical coordinates of the point at the arrow of an origin translated vector \end{DoxyCompactList}\item 
bool \hyperlink{namespacecloud__object__segmentation_1_1aux_ae9f3fcf2ebe5ed733eceb4dc5845d418}{coord\+\_\+cmp} (std\+::vector$<$ float $>$ coords\+\_\+1, std\+::vector$<$ float $>$ coords\+\_\+2, float precision)
\begin{DoxyCompactList}\small\item\em coords\+\_\+cmp compares the inclination and azimuth angles (spherical coordinate system) of two points \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\float \hyperlink{namespacecloud__object__segmentation_1_1aux_aa39c38ffc1379874ede49b1079c21a34}{euclidian\+\_\+dist} (T a\+\_\+1, T b\+\_\+1, T c\+\_\+1, T a\+\_\+2, T b\+\_\+2, T c\+\_\+2)
\begin{DoxyCompactList}\small\item\em performs the euclidian distance calculation between two 3D points \end{DoxyCompactList}\item 
\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} \hyperlink{namespacecloud__object__segmentation_1_1aux_a0a4c9ef4676b55cbb72ef7212d112d00}{vect\+\_\+2pts} (pcl\+::\+Point\+X\+Y\+Z\+R\+GB pt\+\_\+1, pcl\+::\+Point\+X\+Y\+Z\+R\+GB pt\+\_\+2)
\begin{DoxyCompactList}\small\item\em vect\+\_\+2pts creates a vector using two points \end{DoxyCompactList}\item 
\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} \hyperlink{namespacecloud__object__segmentation_1_1aux_a6039339e8cdf62a949421f73033d2de9}{cross\+\_\+product} (\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} vect\+\_\+1, \hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} vect\+\_\+2)
\begin{DoxyCompactList}\small\item\em cross\+\_\+product calculates the cross product of two vectors \end{DoxyCompactList}\item 
\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} \hyperlink{namespacecloud__object__segmentation_1_1aux_adc7f08f362cb4005bfd39fb9e61b17e6}{inverse} (\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} vect)
\begin{DoxyCompactList}\small\item\em inverse inverses the coordinates of a vector \end{DoxyCompactList}\item 
\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} \hyperlink{namespacecloud__object__segmentation_1_1aux_a6064004fbb1cb4057191d67804ff4df4}{translate\+\_\+origin} (float x\+\_\+1, float y\+\_\+1, float z\+\_\+1, float x\+\_\+2, float y\+\_\+2, float z\+\_\+2)
\begin{DoxyCompactList}\small\item\em translate\+\_\+origin translates a vector into the origin \end{DoxyCompactList}\item 
\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} \hyperlink{namespacecloud__object__segmentation_1_1aux_a8a8fe6b426ed28820fbd1102eaf204c8}{vector\+\_\+avg} (std\+::vector$<$ \hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} $>$ vectors)
\begin{DoxyCompactList}\small\item\em vect\+\_\+avg calculates the average of the vectors within an array of vectors \end{DoxyCompactList}\item 
\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} \hyperlink{namespacecloud__object__segmentation_1_1aux_a6d8f8292c05ff01191a1b0f62e48c173}{vector\+\_\+abs} (\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} vect)
\begin{DoxyCompactList}\small\item\em vector\+\_\+abs calculates the absolute values of the coordinates of a vector \end{DoxyCompactList}\item 
\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} \hyperlink{namespacecloud__object__segmentation_1_1aux_a88a6c55fd9d9769fea1898f101102c94}{normalize\+\_\+normal} (\hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{vector3} normal)
\begin{DoxyCompactList}\small\item\em normalize\+\_\+normal maps the values of the coordinates of a normal between 0 and 1 \end{DoxyCompactList}\item 
void \hyperlink{namespacecloud__object__segmentation_1_1aux_ad2dd6bc1e223cf47809b8b86454466ba}{normal\+\_\+to\+\_\+rgb} (pcl\+::\+Point\+X\+Y\+Z\+R\+GB $\ast$pt\+\_\+ptr, \hyperlink{classcloud__object__segmentation_1_1aux_1_1vector3}{aux\+::vector3} normal)
\begin{DoxyCompactList}\small\item\em norm\+\_\+to\+\_\+rgb calculates the r, g and b values of a point in function of the coordinates of a given normal \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!coord\+\_\+cmp@{coord\+\_\+cmp}}
\index{coord\+\_\+cmp@{coord\+\_\+cmp}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{coord\+\_\+cmp(std\+::vector$<$ float $>$ coords\+\_\+1, std\+::vector$<$ float $>$ coords\+\_\+2, float precision)}{coord_cmp(std::vector< float > coords_1, std::vector< float > coords_2, float precision)}}]{\setlength{\rightskip}{0pt plus 5cm}bool cloud\+\_\+object\+\_\+segmentation\+::aux\+::coord\+\_\+cmp (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ float $>$}]{coords\+\_\+1, }
\item[{std\+::vector$<$ float $>$}]{coords\+\_\+2, }
\item[{float}]{precision}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_ae9f3fcf2ebe5ed733eceb4dc5845d418}{}\label{namespacecloud__object__segmentation_1_1aux_ae9f3fcf2ebe5ed733eceb4dc5845d418}


coords\+\_\+cmp compares the inclination and azimuth angles (spherical coordinate system) of two points 


\begin{DoxyParams}{Parameters}
{\em coords\+\_\+1} & is an array containing the radius, inclination and azimuth of the first point \\
\hline
{\em coords\+\_\+2} & is an array containing the radius, inclination and azimuth of the second point \\
\hline
{\em precision} & is a float that defines the degree of precision of the comparison \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::logic\+\_\+error} & when precision is 0 \\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
true if the angles are equal within the boundries of epsilon 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!cross\+\_\+product@{cross\+\_\+product}}
\index{cross\+\_\+product@{cross\+\_\+product}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{cross\+\_\+product(vector3 vect\+\_\+1, vector3 vect\+\_\+2)}{cross_product(vector3 vect_1, vector3 vect_2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector3} cloud\+\_\+object\+\_\+segmentation\+::aux\+::cross\+\_\+product (
\begin{DoxyParamCaption}
\item[{{\bf vector3}}]{vect\+\_\+1, }
\item[{{\bf vector3}}]{vect\+\_\+2}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a6039339e8cdf62a949421f73033d2de9}{}\label{namespacecloud__object__segmentation_1_1aux_a6039339e8cdf62a949421f73033d2de9}


cross\+\_\+product calculates the cross product of two vectors 

the cross product of two vectors only has sense in R$^\wedge$3 
\begin{DoxyParams}{Parameters}
{\em vect\+\_\+1} & is the first factor of the product \\
\hline
{\em vect\+\_\+2} & is the second factor of the product \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the vector result of the operation 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!euclidian\+\_\+dist@{euclidian\+\_\+dist}}
\index{euclidian\+\_\+dist@{euclidian\+\_\+dist}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{euclidian\+\_\+dist(\+T a\+\_\+1, T b\+\_\+1, T c\+\_\+1, T a\+\_\+2, T b\+\_\+2, T c\+\_\+2)}{euclidian_dist(T a_1, T b_1, T c_1, T a_2, T b_2, T c_2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ float cloud\+\_\+object\+\_\+segmentation\+::aux\+::euclidian\+\_\+dist (
\begin{DoxyParamCaption}
\item[{T}]{a\+\_\+1, }
\item[{T}]{b\+\_\+1, }
\item[{T}]{c\+\_\+1, }
\item[{T}]{a\+\_\+2, }
\item[{T}]{b\+\_\+2, }
\item[{T}]{c\+\_\+2}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_aa39c38ffc1379874ede49b1079c21a34}{}\label{namespacecloud__object__segmentation_1_1aux_aa39c38ffc1379874ede49b1079c21a34}


performs the euclidian distance calculation between two 3D points 

\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!float\+\_\+avg@{float\+\_\+avg}}
\index{float\+\_\+avg@{float\+\_\+avg}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{float\+\_\+avg(std\+::vector$<$ float $>$ floats)}{float_avg(std::vector< float > floats)}}]{\setlength{\rightskip}{0pt plus 5cm}float cloud\+\_\+object\+\_\+segmentation\+::aux\+::float\+\_\+avg (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ float $>$}]{floats}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a16d1866d46bb2c56c66f9d703fa7189e}{}\label{namespacecloud__object__segmentation_1_1aux_a16d1866d46bb2c56c66f9d703fa7189e}


float\+\_\+avg calculates the average of float numbers 


\begin{DoxyParams}{Parameters}
{\em floats} & is the array of the floats to be averaged \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the averaged of the floats found within the parameter array 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!float\+\_\+cmp@{float\+\_\+cmp}}
\index{float\+\_\+cmp@{float\+\_\+cmp}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{float\+\_\+cmp(float float\+\_\+1, float float\+\_\+2, float precision)}{float_cmp(float float_1, float float_2, float precision)}}]{\setlength{\rightskip}{0pt plus 5cm}bool cloud\+\_\+object\+\_\+segmentation\+::aux\+::float\+\_\+cmp (
\begin{DoxyParamCaption}
\item[{float}]{float\+\_\+1, }
\item[{float}]{float\+\_\+2, }
\item[{float}]{precision}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a6dbc39e59b20bcc59affd0aad8496dc3}{}\label{namespacecloud__object__segmentation_1_1aux_a6dbc39e59b20bcc59affd0aad8496dc3}


float\+\_\+cmp compares two floats with a certain precision 


\begin{DoxyParams}{Parameters}
{\em float\+\_\+1} & is the first float of the comparison \\
\hline
{\em float\+\_\+2} & is the second float of the comparison \\
\hline
{\em precision} & is a float that defines the degree of precision of the comparison \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::logic\+\_\+error} & when precision is 0 \\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
true if the two parameter floats are equal within a certain range 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!inverse@{inverse}}
\index{inverse@{inverse}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{inverse(vector3 vect)}{inverse(vector3 vect)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector3} cloud\+\_\+object\+\_\+segmentation\+::aux\+::inverse (
\begin{DoxyParamCaption}
\item[{{\bf vector3}}]{vect}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_adc7f08f362cb4005bfd39fb9e61b17e6}{}\label{namespacecloud__object__segmentation_1_1aux_adc7f08f362cb4005bfd39fb9e61b17e6}


inverse inverses the coordinates of a vector 


\begin{DoxyParams}{Parameters}
{\em vect} & is the vector to be inversed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the inversed vector 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!map@{map}}
\index{map@{map}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{map(float x, float in\+\_\+min, float in\+\_\+max, float out\+\_\+min, float out\+\_\+max)}{map(float x, float in_min, float in_max, float out_min, float out_max)}}]{\setlength{\rightskip}{0pt plus 5cm}float cloud\+\_\+object\+\_\+segmentation\+::aux\+::map (
\begin{DoxyParamCaption}
\item[{float}]{x, }
\item[{float}]{in\+\_\+min, }
\item[{float}]{in\+\_\+max, }
\item[{float}]{out\+\_\+min, }
\item[{float}]{out\+\_\+max}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_afdc9858a2a1aa966c6b9cf71a4549718}{}\label{namespacecloud__object__segmentation_1_1aux_afdc9858a2a1aa966c6b9cf71a4549718}


map maps a number found within a range to another range 


\begin{DoxyParams}{Parameters}
{\em x} & is the number to be mapped \\
\hline
{\em in\+\_\+min} & is minimum of the in range \\
\hline
{\em in\+\_\+max} & is the maximum of the in range \\
\hline
{\em out\+\_\+min} & is the minimum of the out range \\
\hline
{\em out\+\_\+max} & is the maximum of the out range \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the mapped float 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!normal\+\_\+to\+\_\+rgb@{normal\+\_\+to\+\_\+rgb}}
\index{normal\+\_\+to\+\_\+rgb@{normal\+\_\+to\+\_\+rgb}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{normal\+\_\+to\+\_\+rgb(pcl\+::\+Point\+X\+Y\+Z\+R\+G\+B $\ast$pt\+\_\+ptr, aux\+::vector3 normal)}{normal_to_rgb(pcl::PointXYZRGB *pt_ptr, aux::vector3 normal)}}]{\setlength{\rightskip}{0pt plus 5cm}void cloud\+\_\+object\+\_\+segmentation\+::aux\+::normal\+\_\+to\+\_\+rgb (
\begin{DoxyParamCaption}
\item[{pcl\+::\+Point\+X\+Y\+Z\+R\+GB $\ast$}]{pt\+\_\+ptr, }
\item[{{\bf aux\+::vector3}}]{normal}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_ad2dd6bc1e223cf47809b8b86454466ba}{}\label{namespacecloud__object__segmentation_1_1aux_ad2dd6bc1e223cf47809b8b86454466ba}


norm\+\_\+to\+\_\+rgb calculates the r, g and b values of a point in function of the coordinates of a given normal 


\begin{DoxyParams}{Parameters}
{\em pt} & is a pointer to the point to be colored \\
\hline
{\em normal} & is the normal used for the calculation \\
\hline
\end{DoxyParams}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!normalize\+\_\+normal@{normalize\+\_\+normal}}
\index{normalize\+\_\+normal@{normalize\+\_\+normal}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{normalize\+\_\+normal(vector3 normal)}{normalize_normal(vector3 normal)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector3} cloud\+\_\+object\+\_\+segmentation\+::aux\+::normalize\+\_\+normal (
\begin{DoxyParamCaption}
\item[{{\bf vector3}}]{normal}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a88a6c55fd9d9769fea1898f101102c94}{}\label{namespacecloud__object__segmentation_1_1aux_a88a6c55fd9d9769fea1898f101102c94}


normalize\+\_\+normal maps the values of the coordinates of a normal between 0 and 1 


\begin{DoxyParams}{Parameters}
{\em normal} & is the normal to be mapped \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the mapped (normalized) normal 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!set\+\_\+precision@{set\+\_\+precision}}
\index{set\+\_\+precision@{set\+\_\+precision}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{set\+\_\+precision(float float\+\_\+num, float precision)}{set_precision(float float_num, float precision)}}]{\setlength{\rightskip}{0pt plus 5cm}float cloud\+\_\+object\+\_\+segmentation\+::aux\+::set\+\_\+precision (
\begin{DoxyParamCaption}
\item[{float}]{float\+\_\+num, }
\item[{float}]{precision}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a4b661185614d1037447a89a148a204eb}{}\label{namespacecloud__object__segmentation_1_1aux_a4b661185614d1037447a89a148a204eb}


set\+\_\+precision sets the number of digits after the decimal 


\begin{DoxyParams}{Parameters}
{\em float\+\_\+num} & is the number to be truncated \\
\hline
{\em precision} & is the number of digits after the decimal \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::logic\+\_\+error} & when precision is negative, null or not a multiple of 10 \\
\hline
\end{DoxyExceptions}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!spherical\+\_\+coords@{spherical\+\_\+coords}}
\index{spherical\+\_\+coords@{spherical\+\_\+coords}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{spherical\+\_\+coords(aux\+::vector3 vect)}{spherical_coords(aux::vector3 vect)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ float $>$ cloud\+\_\+object\+\_\+segmentation\+::aux\+::spherical\+\_\+coords (
\begin{DoxyParamCaption}
\item[{{\bf aux\+::vector3}}]{vect}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_ae659a392c3508e64e4a82bb61ee4cc86}{}\label{namespacecloud__object__segmentation_1_1aux_ae659a392c3508e64e4a82bb61ee4cc86}


spherical\+\_\+coordinates calculates the spherical coordinates of the point at the arrow of an origin translated vector 


\begin{DoxyParams}{Parameters}
{\em vect} & the vector having its root at the origin \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an array of 3 floats corresponding to the 3 spherical coordinates of a point (radius, inclination and azimuth) 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!translate\+\_\+origin@{translate\+\_\+origin}}
\index{translate\+\_\+origin@{translate\+\_\+origin}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{translate\+\_\+origin(float x\+\_\+1, float y\+\_\+1, float z\+\_\+1, float x\+\_\+2, float y\+\_\+2, float z\+\_\+2)}{translate_origin(float x_1, float y_1, float z_1, float x_2, float y_2, float z_2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector3} cloud\+\_\+object\+\_\+segmentation\+::aux\+::translate\+\_\+origin (
\begin{DoxyParamCaption}
\item[{float}]{x\+\_\+1, }
\item[{float}]{y\+\_\+1, }
\item[{float}]{z\+\_\+1, }
\item[{float}]{x\+\_\+2, }
\item[{float}]{y\+\_\+2, }
\item[{float}]{z\+\_\+2}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a6064004fbb1cb4057191d67804ff4df4}{}\label{namespacecloud__object__segmentation_1_1aux_a6064004fbb1cb4057191d67804ff4df4}


translate\+\_\+origin translates a vector into the origin 


\begin{DoxyParams}{Parameters}
{\em x\+\_\+1} & is the x coordinate of the point at the root of the vector \\
\hline
{\em y\+\_\+1} & is the y coordinate of the point at the root of the vector \\
\hline
{\em z\+\_\+1} & is the z coordinate of the point at the root of the vector \\
\hline
{\em x\+\_\+2} & is the x coordinate of the point at the arrow of the vector \\
\hline
{\em y\+\_\+2} & is the y coordinate of the point at the arrow of the vector \\
\hline
{\em z\+\_\+2} & is the z coordinate of the point at the arrow of the vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the vector as a result of the translation 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!vect\+\_\+2pts@{vect\+\_\+2pts}}
\index{vect\+\_\+2pts@{vect\+\_\+2pts}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{vect\+\_\+2pts(pcl\+::\+Point\+X\+Y\+Z\+R\+G\+B pt\+\_\+1, pcl\+::\+Point\+X\+Y\+Z\+R\+G\+B pt\+\_\+2)}{vect_2pts(pcl::PointXYZRGB pt_1, pcl::PointXYZRGB pt_2)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector3} cloud\+\_\+object\+\_\+segmentation\+::aux\+::vect\+\_\+2pts (
\begin{DoxyParamCaption}
\item[{pcl\+::\+Point\+X\+Y\+Z\+R\+GB}]{pt\+\_\+1, }
\item[{pcl\+::\+Point\+X\+Y\+Z\+R\+GB}]{pt\+\_\+2}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a0a4c9ef4676b55cbb72ef7212d112d00}{}\label{namespacecloud__object__segmentation_1_1aux_a0a4c9ef4676b55cbb72ef7212d112d00}


vect\+\_\+2pts creates a vector using two points 


\begin{DoxyParams}{Parameters}
{\em pt\+\_\+1} & is the point at the arrow of the vector \\
\hline
{\em pt\+\_\+2} & is the point at the \textquotesingle{}root\textquotesingle{} of the vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the vector that has been created using 2 points 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!vector\+\_\+abs@{vector\+\_\+abs}}
\index{vector\+\_\+abs@{vector\+\_\+abs}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{vector\+\_\+abs(vector3 vect)}{vector_abs(vector3 vect)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector3} cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector\+\_\+abs (
\begin{DoxyParamCaption}
\item[{{\bf vector3}}]{vect}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a6d8f8292c05ff01191a1b0f62e48c173}{}\label{namespacecloud__object__segmentation_1_1aux_a6d8f8292c05ff01191a1b0f62e48c173}


vector\+\_\+abs calculates the absolute values of the coordinates of a vector 


\begin{DoxyParams}{Parameters}
{\em vect} & is the vector to get the absolute values of \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the resulting, absolute value coordinates vector 
\end{DoxyReturn}
\index{cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}!vector\+\_\+avg@{vector\+\_\+avg}}
\index{vector\+\_\+avg@{vector\+\_\+avg}!cloud\+\_\+object\+\_\+segmentation\+::aux@{cloud\+\_\+object\+\_\+segmentation\+::aux}}
\subsubsection[{\texorpdfstring{vector\+\_\+avg(std\+::vector$<$ vector3 $>$ vectors)}{vector_avg(std::vector< vector3 > vectors)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vector3} cloud\+\_\+object\+\_\+segmentation\+::aux\+::vector\+\_\+avg (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf vector3} $>$}]{vectors}
\end{DoxyParamCaption}
)}\hypertarget{namespacecloud__object__segmentation_1_1aux_a8a8fe6b426ed28820fbd1102eaf204c8}{}\label{namespacecloud__object__segmentation_1_1aux_a8a8fe6b426ed28820fbd1102eaf204c8}


vect\+\_\+avg calculates the average of the vectors within an array of vectors 


\begin{DoxyParams}{Parameters}
{\em vectors} & is the array of the vectors we need the average of \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the vector resulted the average of the vectors found within the parameter 
\end{DoxyReturn}
